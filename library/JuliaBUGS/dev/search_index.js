var documenterSearchIndex = {"docs":
[{"location":"compilation_target/#Compilation-Targets","page":"Compilation Targets","title":"Compilation Targets","text":"","category":"section"},{"location":"compilation_target/#DAG","page":"Compilation Targets","title":"DAG","text":"","category":"section"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"Directed Acyclic Graph (DAG) is classical representation of probabilistic models. ","category":"page"},{"location":"compilation_target/#Node-Data","page":"Compilation Targets","title":"Node Data","text":"","category":"section"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"SymbolicPPL.VertexInfo","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"Vertex store the following information:","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"the name of the variable\nthe parents of the variable\nthe node function (see Node Function))\nwhether the variable is data or not","category":"page"},{"location":"compilation_target/#Node-Function","page":"Compilation Targets","title":"Node Function","text":"","category":"section"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"The node function is a very flexible representation.  The requirement for a node function is that when evaluate with the input arguments, it returns a Distribution object. This may seems simple, but it can be very powerful. For instance, a mixture model can be represented by a node function similar to","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"function node_f(t, μ_1, μ_2, σ_1, σ_2)\n    if t >= 4\n        return Normal(μ_1, σ_1)\n    else\n        return Normal(μ_2, σ_2)\n    end\nend","category":"page"},{"location":"compilation_target/#Plotting","page":"Compilation Targets","title":"Plotting","text":"","category":"section"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"A good way to debug a model is plotting the Bayesian Network.  We recommend using the TikzGraphs package to plot the Bayesian Network.  The following code shows how to plot the Bayesian Network of the model in the previous section.  Please note that the following code requires local latex environment to work.  For more information regarding installation and more advanced usage of TikzGraphs, please refer to the TikzGraphs.jl.","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"using SymbolicPPL\nusing Graphs, MetaGraphsNext\n\n# Compile model\nexpr = @bugsast begin\n    a ~ dnorm(0, 1)\n    b ~ dnorm(a, 1)\n    c ~ dnorm(a, b)\n    d ~ dnorm(a - b, c)\nend\n\ng = compile(expr, NamedTuple(), :Graph)\ng[:d]\n\n# Plot with TikzGraphs\nusing TikzGraphs, TikzPictures\nimport TikzGraphs: plot\n\nfunction plot(g)\n    color_dict = Dict{Int, String}()\n    for (i, node) in enumerate(vertices(g))\n        if g[label_for(g, node)].is_data\n            color_dict[i] = \"fill=green!10\"\n        else\n            color_dict[i] = \"fill=yellow!10\"\n        end\n    end\n\n    TikzGraphs.plot(\n        g.graph, \n        map(x->string(label_for(g, x)), vertices(g)), \n        node_style=\"draw, rounded corners, fill=blue!10\", \n        node_styles=color_dict,\n        edge_style=\"black\"\n    )\nend","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"Also plotting with GraphRecipes.jl is also possible, but not recommended.","category":"page"},{"location":"compilation_target/","page":"Compilation Targets","title":"Compilation Targets","text":"# Plot with GraphRecipes\n# The plot may not\nusing Plots, GraphRecipes\ngraphplot(\n    g.graph,\n    names = map(x->label_for(g, x), vertices(g)),\n    curves = false,\n    method = :tree\n)","category":"page"},{"location":"compilation_target/#Turing-Model","page":"Compilation Targets","title":"Turing Model","text":"","category":"section"},{"location":"compilation_target/#More-to-come","page":"Compilation Targets","title":"More to come","text":"","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Compile","page":"API","title":"Compile","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"compile","category":"page"},{"location":"api/#JuliaBUGS.compile","page":"API","title":"JuliaBUGS.compile","text":"compile(model_def, data, initializations)\n\nCompile a BUGS model into a log density problem.\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"abs\ncloglog\nequals\nexp\ninprod\ninverse\nlog\nlogdet\nlogfact\nloggam\nicloglog\nlogit\nmexp\nmax\nmean\nmin\nphi\npow\nsqrt\nrank\nranked\nround\nsd\nsoftplus\nsort\n_step\nsum\ntrunc\nsin\narcsin\narcsinh\ncos\narccos\narccosh\ntan\narctan\narctanh","category":"page"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.abs","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.abs","text":"abs(x)\n\nAbsolute value of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.cloglog","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.cloglog","text":"cloglog(x)\n\nComplementary log-log function of x. \n\ncloglog(x) = log(-log(1 - x))\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.equals","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.equals","text":"equals(x, y)\n\nReturns 1 if x is equal to y, 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.exp","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.exp","text":"exp(x)\n\nExponential of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.inprod","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.inprod","text":"inprod(a, b)\n\nInner product of a and b.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.inverse","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.inverse","text":"inverse(v)\n\nInverse of matrix v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.log","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.log","text":"log(x)\n\nNatural logarithm of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logdet","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logdet","text":"logdet(v)\n\nLogarithm of the determinant of matrix v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logfact","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logfact","text":"logfact(x)\n\nLogarithm of the factorial of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.loggam","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.loggam","text":"loggam(x)\n\nLogarithm of the gamma function of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.icloglog","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.icloglog","text":"icloglog(x)\n\nInverse complementary log-log function of x. \n\nicloglog(x) = 1 - exp(-exp(x))\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logit","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logit","text":"logit(x)\n\nLogit function of x. \n\nlogit(x) = log(x  (1 - x))\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.mexp","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.mexp","text":"mexp(x)\n\nMatrix exponential of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.max","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.max","text":"max(args...)\n\nReturn the maximum value of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.mean","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.mean","text":"mean(v::AbstractVector)\n\nReturn the mean of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.min","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.min","text":"min(args...)\n\nReturn the minimum value of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.phi","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.phi","text":"phi(x)\n\nCumulative distribution function (CDF) of the standard normal distribution evaluated at x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.pow","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.pow","text":"pow(a, b)\n\nReturn a raised to the power of b.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sqrt","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sqrt","text":"sqrt(x)\n\nReturn the square root of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.rank","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.rank","text":"rank(v::Vector, i::Int)\n\nReturn the rank of the i-th element of v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.ranked","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.ranked","text":"ranked(v::Vector, i::Int)\n\nReturn the i-th element of v sorted in ascending order.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.round","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.round","text":"round(x)\n\nRound x to the nearest integer.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sd","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sd","text":"sd(v::Vector)\n\nReturn the standard deviation of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.softplus","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.softplus","text":"softplus(x)\n\nReturn the softplus function of x, defined as log(1 + exp(x)).\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sort","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sort","text":"sort(v::Vector)\n\nReturn a sorted copy of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives._step","page":"Functions","title":"JuliaBUGS.BUGSPrimitives._step","text":"_step(x)\n\nReturn 1 if x is greater than 0, and 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sum","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sum","text":"sum(args...)\n\nReturn the sum of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.trunc","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.trunc","text":"trunc(x)\n\nReturn the integer part of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sin","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sin","text":"sin(x)\n\nReturn the sine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arcsin","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arcsin","text":"arcsin(x)\n\nReturn the arcsine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arcsinh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arcsinh","text":"arcsinh(x)\n\nReturn the inverse hyperbolic sine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.cos","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.cos","text":"cos(x)\n\nReturn the cosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arccos","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arccos","text":"arccos(x)\n\nReturn the arccosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arccosh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arccosh","text":"arccosh(x)\n\nReturn the inverse hyperbolic cosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.tan","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.tan","text":"tan(x)\n\nReturn the tangent of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arctan","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arctan","text":"arctan(x)\n\nReturn the arctangent of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arctanh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arctanh","text":"arctanh(x)\n\nReturn the inverse hyperbolic tangent of x.\n\n\n\n\n\n","category":"function"},{"location":"ast/#Syntax-and-model-representation","page":"AST Translation","title":"Syntax & model representation","text":"","category":"section"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"We provide some convenience functions to work with graphical models syntactically in Julia, inspired very much by BUGS. BUGS (Bayesian inference Using Gibbs Sampling), as the name says, is a probabilistic programming system originally designed for Gibbs sampling. For this purpose, BUGS models define, implicitly, only a directed graph of variables, not an ordered sequence of statements like other PPLs. They do have the advantage of being relatively restricted (while still able to express a very large class of practically used models), and hence allowing lots of static analysis.   Specifically, stochastic control flow is disallowed (except for the “mixture model” case of indexing by a stochastic variable, indexing with stochastic variable is not supported yet).","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"We provide a macro solution which allows to directly use Julia code corresponding to BUGS code:","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"@bugsast begin\n    for i in 1:N\n        Y[i] ~ dnorm(μ[i], τ)\n        μ[i] = α + β * (x[i] - x̄)\n    end\n    τ ~ dgamma(0.001, 0.001)\n    σ = 1 / sqrt(τ)\n    logτ = log(τ)\n    α = dnorm(0.0, 1e-6)\n    β = dnorm(0.0, 1e-6)\nend","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"BUGS syntax carries over almost one-to-one to Julia. The macro checks that only allowed syntactic forms are used and then applies some minor normalizations. The most prominent normalization is the conversion of stochastic statements (tildes) from :call expressions to first-class forms:","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"quote\n    for i = 1:N\n        $(Expr(:~, :(Y[i]), :(dnorm(μ[i], τ))))\n        μ[i] = α + β * (x[i] - x̄)\n    end\n    $(Expr(:~, :τ, :(dgamma(0.001, 0.001))))\n    σ = 1 / sqrt(τ)\n    logτ = log(τ)\n    α = dnorm(0.0, 1.0e-6)\n    β = dnorm(0.0, 1.0e-6)\nend","category":"page"},{"location":"ast/#Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro","page":"AST Translation","title":"Add New Functions – this should be replaced by the @bugsfunction macro","text":"","category":"section"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"It should be reasonably easy to define anything else on top of this representation by using simple if statements, and Meta.isexpr. Interpolation ($(…)) is allowed in @bugsast; the result of the macro is a :quote expression, in which the interpolations are just left as is. I.e.,","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"@bugsast begin\n    x = $(myfunc(somevalue))\nend","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"will end up as ","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"quote\n    x = $(myfunc(somevalue))\nend","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"with quasi-quotation working as usual. (Using interpolation, it is possible to construct ASTs which bypass validation and do not correspond to valid BUGS programs – use it with care.)","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"In addition, there is a string macro bugsmodel which should work with original (R-like) BUGS syntax:","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"bugsmodel\"\"\"\n    for (i in 1:5) {\n        y[i] ~ dnorm(mu[i], tau)\n        mu[i] <- alpha + beta*(x[i] - mean(x[]))\n    }\n    \n    alpha ~ dflat()\n    beta ~ dflat()\n    tau <- 1/sigma2\n    log(sigma2) <- 2*log.sigma\n    log.sigma ~ dflat()\n\"\"\"","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"Internally, the only thing this does is apply a couple of regex-based substitutions to convert the code to the equivalent Julia, Meta.parse the result, and apply the same logic as @bugsast. We encourage users to write new program using the Julia-native syntax, because of better debuggability and perks like syntax highlighting.  But in the case of testing out legacy program, the macro upfront should work for copy-paste situations. All variable names are preventively wrapped in var-strings; this allows R-style names like b.abd.","category":"page"},{"location":"ast/#AST-structure","page":"AST Translation","title":"AST structure","text":"","category":"section"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"Basically, all forms which obviously translate from BUGS to Julia are preserved in the equivalent Julia Exprs (:call, :for, :if, :=, :ref). The resulting code should be as close to executable as possible. Special forms are converted, though, in order to simplify pattern matching:","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"~ statements are parsed as :call by Julia, and get their own form (dc[i] ~ dunif(0, 20) → (:~, (:ref, :dc, :i), (:call, :dunif, 0, 20))).\nIn logical assignments with link functions, the block on the right hand side, automatically created by the Julia parser, is removed. The result is therefore an := expression with a direct :call on the LHS.\nCensoring and truncation annoations are converted to :censored and :truncated forms (dnorm(x, μ) C (, 10) → (:censored, (:call, :dnorm, :x, :μ), :nothing, 100)). The left-out limits (C (, 100)) are filled with nothing. In @bugsast, you may just use normal calls truncated(dist, l, r) and censored(dist, l, r), which will be raised to special forms automatically.\nEmpty ranges are automatically filled with slices (x[,] → (:ref, :x, :(:), :(:))).","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"In addition, forms that have both a :call representation and their own lowered form are tried to be normalized to the latter; currently, this concerns getindex to :ref, and : to :(:).  LineNumberNodes are stripped completely.","category":"page"},{"location":"ast/#Semantics","page":"AST Translation","title":"Semantics","text":"","category":"section"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"The semantics of BUGS are not really made explicit.  I have tried to \"reconstruct\" a formalization and type system, but this is still ongoing work.","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"BUGS programs, in contrast to some other PPLs, have the sole purpose of implicitly describing a directed graphical model. This means that they don’t really have operational semantics – there are not declarations of variables, input, outputs, etc., nor is order relevant. A program like","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"model\n{\n  for( i in 1 : N ) {\n    for( j in 1 : T ) {\n      Y[i , j] ~ dnorm(mu[i , j], tau.c)\n      mu[i , j] <- alpha[i] + beta[i] * (x[j] - xbar)\n    }\n    alpha[i] ~ dnorm(alpha.c, alpha.tau)\n    beta[i] ~ dnorm(beta.c, beta.tau)\n  }\n  tau.c ~ dgamma(0.001, 0.001)\n  sigma <- 1 / sqrt(tau.c)\n  alpha.c ~ dnorm(0.0, 1.0E-6)\n  alpha.tau ~ dgamma(0.001, 0.001)\n  beta.c ~ dnorm(0.0, 1.0E-6)\n  beta.tau ~ dgamma(0.001, 0.001)\n  alpha0 <- alpha.c - xbar * beta.c\n}","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"denotes only a certain relationship between (logical or stochastic) nodes in a graph. Variables are either names of nodes within the program (when on the LHS of a sampling or assignement statement, like alpha or sigma), or otherwise constant parts of the “data” (like N and xbar), with which a model must be combined to instantiate it.","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"Loops are just a form of “plate notation”: they allow to concisely express repetition of equal statements over many constant indices, and are thus equivalent to their rolled-out form given the data.","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"In the BUGS language the type information is fine grained: each component of a tensor can have different type information. […] One common case is where some components of a tensor have been observed while other components need to be estimated.","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"In addition to standard type checking of semantic consistency between variables and function calls, like any other expression-based language does, BUGS has the additional task of making sense of the indexed variables, which can occur in many places and arbitrary order, and ensuring that stochasticity is only used where it is allowed (e.g., not on the LHS of assignments, or within loop ranges).","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"A “type checker” for BUGS would therefore have multiple purposes:","category":"page"},{"location":"ast/","page":"AST Translation","title":"AST Translation","text":"Checking semantic constraints, such as correct argument types for functions and distributions,\nChecking stochasticity constraints, such as constantness of loop ranges,\nUnify types, ranks, and stochasticity of all variables – which can be specified in any order.","category":"page"},{"location":"array/#Array-Interface","page":"Array Interface","title":"Array Interface","text":"","category":"section"},{"location":"array/","page":"Array Interface","title":"Array Interface","text":"There are subtleties involved in using the array syntax of BUGS.  Two elements of the same array can be one logical variable and one stochastic variable. ","category":"page"},{"location":"array/#Size-Deduction","page":"Array Interface","title":"Size Deduction","text":"","category":"section"},{"location":"array/","page":"Array Interface","title":"Array Interface","text":"The size of data arrays will not be deducted.","category":"page"},{"location":"array/","page":"Array Interface","title":"Array Interface","text":"Otherwise, the array size will be deduced from the model definition. The unrolling will evaluate all the indices into concrete values (the exception is stochastic indexing).  We will treat the largest index as the size of the array for a specific dimension. ","category":"page"},{"location":"array/#Nested-Indexing","page":"Array Interface","title":"Nested Indexing","text":"","category":"section"},{"location":"array/","page":"Array Interface","title":"Array Interface","text":"Nested indexing can be the source of many errors, especially while data is involved.","category":"page"},{"location":"array/#Colon-Indexing","page":"Array Interface","title":"Colon Indexing","text":"","category":"section"},{"location":"array/","page":"Array Interface","title":"Array Interface","text":"Users should be cautious when using the colon indexing syntax.  Colon indexing requires knowledge of the size of the array.  If a loop bound requires a colon indexing, the potential size information from the loop body will not be concerned. ","category":"page"},{"location":"array/#Multivariate-Variables","page":"Array Interface","title":"Multivariate Variables","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dnorm\ndlogis\ndt\nTDistShiftedScaled\nddexp\ndflat\nFlat\nTruncatedFlat\ndexp\ndchisqr\ndweib\ndlnorm\ndgamma\ndpar\ndgev\ndgpar\ndf\ndunif\ndbeta\ndmnorm\ndmt\ndwish\nddirich\ndbern\ndbin\ndcat\ndpois\ndgeom\ndnegbin\ndbetabin\ndhyper\ndmulti","category":"page"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dnorm","text":"dnorm(μ, τ)\n\nConstruct a Normal  distribution object in Julia using mean μ and precision τ as parameters. \n\nIn many statistical contexts, including the BUGS family of software, the Normal distribution is parametrized using precision, which is defined as the reciprocal of the variance. In contrast, Julia's Distributions package parametrizes the Normal distribution using mean (μ) and standard deviation (σ). This function accepts the mean μ and precision τ as inputs, then calculates the standard deviation as σ = √(1 / τ), and returns a Normal distribution object with mean μ and standard deviation σ.\n\nThe probability density function (PDF) of the Normal distribution as defined in the BUGS family of software is:\n\np(xμτ) = sqrtfracτ2π e^-τ frac(x-μ)^22\n\nIn this equation, x is the random variable, μ is the mean of the distribution, and τ is the precision.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dlogis","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dlogis","text":"dlogis(μ, τ)\n\nReturn a Logistic  distribution object with location parameter μ and scale parameter s, where s = 1  τ.\n\nThe mathematical form of the PDF for a Logistic distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτ e^-sqrtτ(x-μ)(1+e^-sqrtτ(x-μ))^2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dt","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dt","text":"dt(μ, τ, ν)\n\nConstruct a Student's t-distribution object with ν degrees of freedom, location μ, and scale σ = (1  τ). \n\nIf μ is 0 and σ is 1, the function returns a TDist object from Distributions.jl. Otherwise, it returns a TDistShiftedScaled object.\n\nThe mathematical form of the PDF for a Student's t-distribution is given by:\n\np(xνμσ) = fracΓ((ν+1)2)Γ(ν2) νπσ\nleft(1+frac1νleft(fracx-μσright)^2right)^-fracν+12\n\nend\n\nThe mathematical form of the log-PDF for a Student's t-distribution is given by:\n\nlog(p(xνμσ)) = log(Γ((ν+1)2)) - log(Γ(ν2)) - frac12log(νπσ) - fracν+12 logleft(1+frac1νleft(fracx-μσright)^2right)\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.TDistShiftedScaled","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.TDistShiftedScaled","text":"TDistShiftedScaled(ν, μ, σ)\n\nA Student's t-distribution object with ν degrees of freedom, location μ, and scale σ. \n\nThis struct allows for a shift (determined by μ) and a scale (determined by σ) of the standard Student's t-distribution provided by the Distributions package. \n\nOnly pdf and logpdf are implemented for this distribution.\n\nSee Also\n\nTDist\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.ddexp","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.ddexp","text":"ddexp(μ, τ)\n\nReturn a Laplace (Double Exponential)  distribution object with location μ and scale b = 1  τ.\n\nThe mathematical form of the PDF for a Laplace distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτ2 e^-sqrtτ x-μ\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dflat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dflat","text":"dflat()\n\nA distribution type representing a flat (uniform) prior over the real line. This is not a valid probability distribution, but can be used to represent a non-informative prior in Bayesian statistics. The cdf, logcdf, quantile, cquantile, rand, and rand methods are not implemented for this distribution, as they don't have meaningful definitions in the context of a flat prior. When use in a model, the parameters always need to be initialized to a valid value.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.Flat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.Flat","text":"Flat\n\nImplement the flat distribution mimicking the behavior of the dflat distribution in the BUGS family of softwares.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.TruncatedFlat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.TruncatedFlat","text":"TruncatedFlat\n\nTruncated version of the flat distribution.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dexp","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dexp","text":"dexp(λ)\n\nReturn an Exponential  distribution object with rate λ, where the rate is defined as 1  λ in Julia's Distributions package.\n\nThe mathematical form of the PDF for an Exponential distribution in the BUGS family of softwares is given by:\n\np(xλ) = λ e^-λ x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dchisqr","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dchisqr","text":"dchisqr(k)\n\nReturn a Chi-squared  distribution object with k degrees of freedom.\n\nThe mathematical form of the PDF for a Chi-squared distribution in the BUGS family of softwares is given by:\n\np(xk) = frac12^k2 Γ(k2) x^k2 - 1 e^-x2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dweib","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dweib","text":"dweib(a, b)\n\nReturn a Weibull  distribution object with shape parameter a and scale parameter λ = 1  b.\n\nThe Weibull distribution is a common model for event times. The hazard or instantaneous risk of the event is (h(x) = abx^{a-1}). For a < 1 the hazard decreases with x; for a > 1 it increases. a = 1 results in the exponential distribution with constant hazard.\n\nThe mathematical form of the probability density function (PDF) for a Weibull distribution in the BUGS family of softwares is given by:\n\np(xab) = abx^a-1e^-b x^a\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dlnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dlnorm","text":"dlnorm(μ, τ)\n\nReturn a LogNormal  distribution object with location μ and scale σ = 1  τ.\n\nThe mathematical form of the PDF for a LogNormal distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτxsqrt2π e^-τ2 (log(x) - μ)^2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgamma","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgamma","text":"dgamma(a, b)\n\nReturn a Gamma  distribution object with shape a and scale θ = 1  b.\n\nThe mathematical form of the PDF for a Gamma distribution in the BUGS family of softwares is given by:\n\np(xab) = fracb^aΓ(a) x^a-1 e^-bx\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dpar","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dpar","text":"dpar(a, b)\n\nReturn a Pareto  distribution object with scale parameter b and shape parameter a.\n\nThe Pareto distribution, also known as the \"80-20 rule\", states that for many events, roughly 80% of the effects come from 20% of the causes. In terms of wealth distribution, it's often observed that 20% of the population owns 80% of a society's wealth. \n\nThe mathematical form of the probability density function (PDF) for a Pareto distribution in the BUGS family of softwares is given by:\n\np(xab) = fraca b^ax^a+1\n\nIn Julia, this function uses scale parameter b and shape parameter a to construct a Pareto(b, a) distribution object from the Distributions package.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgev","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgev","text":"dgev(μ, σ, η)\n\nReturn a GeneralizedExtremeValue  distribution object with location μ, scale σ, and shape η.\n\nThe mathematical form of the PDF for a Generalized Extreme Value distribution in the BUGS family of softwares is given by:\n\np(xμση) = frac1σ left(1 + η fracx - μσright)^-frac1η - 1 e^-left(1 + η fracx - μσright)^-frac1η\n\nwhere x is the random variable, μ is the location parameter, σ is the scale parameter, and η is the shape parameter. Note that the expression 1 + η ((x - μ)/σ) must be greater than zero for the function to be defined.\n\nIn Julia, this function returns a GeneralizedExtremeValue(μ, σ, η) distribution object from the Distributions package.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgpar","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgpar","text":"dgpar(μ, σ, η)\n\nReturn a GeneralizedPareto  distribution object with location μ, scale σ, and shape η.\n\nThe mathematical form of the PDF for a Generalized Pareto distribution in the BUGS family of softwares is given by:\n\np(xμση) = frac1σ (1 + η ((x - μ)σ))^-1η - 1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.df","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.df","text":"df(n::Real, m::Real, μ::Real=0, τ::Real=1)\n\nReturn an F-distribution  object with n and m degrees of freedom, location μ, and scale τ. Raises a warning if μ ≠ 0 or τ ≠ 1, as these cases are not fully supported.\n\nThe mathematical form of the PDF for an F-distribution in the BUGS family of softwares is given by:\n\np(xn m μ τ) = fracGammaleft(fracn+m2right)Gammaleft(fracn2right) Gammaleft(fracm2right) left(fracnmright)^fracn2 sqrtτ left(sqrtτ(x - μ)right)^fracn2-1 left(1 + fracn sqrtτ(x-μ)mright)^-fracn+m2\n\nwhere x is the random variable, n and m are the degrees of freedom, μ is the location parameter, and τ is the scale parameter. Note that the expression 1 + n sqrt(τ)(x - μ) / m must be greater than zero for the function to be defined.\n\nIn Julia, this function returns an FDist(n, m) distribution object from the Distributions package if μ = 0 and τ = 1.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dunif","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dunif","text":"dunif(a, b)\n\nReturn a Uniform  distribution object with lower bound a and upper bound b.\n\nThe mathematical form of the PDF for a Uniform distribution in the BUGS family of softwares is given by:\n\np(xab) = frac1b - a\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbeta","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbeta","text":"dbeta(a, b)\n\nReturn a Beta  distribution object with shape parameters a and b.\n\nThe mathematical form of the PDF for a Beta distribution in the BUGS family of softwares is given by:\n\np(xab) = fracGamma(a + b)Gamma(a)Gamma(b) x^a-1 (1 - x)^b-1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmnorm","text":"dmnorm(μ::Vector, T::Matrix)\n\nReturn a Multivariate Normal  distribution object with mean vector μ and precision matrix T.\n\nThe mathematical form of the PDF for a Multivariate Normal distribution in the BUGS family of softwares is given by:\n\np(xμT) = (2π)^-k2 T^12 e^-12 (x-μ) T (x-μ)\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmt","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmt","text":"dmt(μ::Vector, T::Matrix, k)\n\nReturn a Multivariate T  distribution object with mean vector μ, precision matrix T, and k degrees of freedom.\n\nThe mathematical form of the PDF for a Multivariate T distribution in the BUGS family of softwares is given by:\n\np(xkμΣ) = fracGamma((k+p)2)Gamma(k2) (kpi)^p2 Σ^12 left(1 + frac1k (x-μ)^T Σ^-1 (x-μ)right)^-frack+p2\n\nwhere x is the random variable, k is the degrees of freedom, μ is the mean vector, Σ is the scale matrix, and p is the dimension of x.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dwish","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dwish","text":"dwish(R::Matrix, k)\n\nReturn a Wishart  distribution object with k degrees of freedom and scale matrix R^(-1).\n\nThe mathematical form of the PDF for a Wishart distribution in the BUGS family of softwares is given by:\n\np(XRk) = X^(k-p-1)2 e^-12 tr(RX)  (2^kp2 R^k2 Γ_p(k2))\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.ddirich","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.ddirich","text":"ddirich(θ::Vector)\n\nReturn a Dirichlet  distribution object with parameters θ.\n\nThe mathematical form of the PDF for a Dirichlet distribution in the BUGS family of softwares is given by:\n\np(xθ) = fracΓ(sum θ) Γ(θ)  x_i^θ_i - 1\n\nwhere x is a vector of random variables, each element x_i of which is between 0 and 1, and the elements of x sum up to 1. θ is a vector of parameters, each θ_i of which is greater than 0.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbern","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbern","text":"dbern(p)\n\nReturn a Bernoulli  distribution object with success probability p.\n\nThe mathematical form of the PMF for a Bernoulli distribution in the BUGS family of softwares is given by:\n\np(xp) = p^x (1 - p)^1-x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbin","text":"dbin(p, n)\n\nReturn a Binomial  distribution object with number of trials n and success probability p.\n\nThe mathematical form of the PMF for a Binomial distribution in the BUGS family of softwares is given by:\n\np(xnp) = binomnx p^x (1 - p)^n-x\n\nend\n\nwhere x is a random variable that can take the values from 0 to n.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dcat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dcat","text":"dcat(p)\n\nReturn a Categorical  distribution object with probabilities p.\n\nThe mathematical form of the PMF for a Categorical distribution in the BUGS family of softwares is given by:\n\np(xp) = px\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dpois","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dpois","text":"dpois(θ)\n\nReturn a Poisson  distribution object with mean (and variance) θ.\n\nThe mathematical form of the PMF for a Poisson distribution in the BUGS family of softwares is given by:\n\np(xθ) = e^-θ θ^x  x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgeom","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgeom","text":"dgeom(θ)\n\nReturn a Geometric  distribution object with success probability θ.\n\nThe mathematical form of the PMF for a Geometric distribution in the BUGS family of softwares is given by:\n\np(xθ) = (1 - θ)^x-1 θ\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dnegbin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dnegbin","text":"dnegbin(p, r)\n\nReturn a Negative Binomial  distribution object with number of failures r and success probability p.\n\nThe mathematical form of the PMF for a Negative Binomial distribution in the BUGS family of softwares is given by:\n\nP(xrp) = binomx + r - 1x (1 - p)^x p^r\n\nwhere x is a random variable that can take non-negative integer values.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbetabin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbetabin","text":"dbetabin(a, b, n)\n\nReturn a Beta Binomial  distribution object with number of trials n and shape parameters a and b.\n\nThe mathematical form of the PMF for a Beta Binomial distribution in the BUGS family of softwares is given by:\n\nP(xa b n) = binomnx binoma + b - 1a + x - 1  binoma + b + n - 1n\n\nwhere x is the number of successful trials, n is the total number of trials, a and b are the shape parameters of the Beta distribution.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dhyper","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dhyper","text":"dhyper(n1, n2, m1, ψ)\n\nReturn a Hypergeometric  distribution object. This distribution is used when sampling without replacement from a population consisting of  n1 successes and n2 failures, with m1 being the number of trials or the sample size.\n\nψ is a scaling parameter which is currently unsupported in this function. Only ψ = 1 is currently supported.\n\nThe mathematical form of the PMF for a Hypergeometric distribution in the BUGS family of softwares is given by:\n\np(x  n1 n2 m1 psi) = fracbinomn1x binomn2m1 - x psi^xsum_i=max(0 m1-n2)^min(n1m1) binomn1i binomn2m1 - i psi^i\n\nIn this formula, x is the number of successes in the sample, n1 is the total number of successes in the population, n2 is the total number of failures in the population, m1 is the number of trials, and \\psi is a scaling parameter.\n\nThe sum in the denominator is over i from u0 to u1, where\n\nu_0 = max(0 m1 - n2) quad u_1 = min(n1 m1) quad textand quad u_0 leq x leq u_1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmulti","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmulti","text":"dmulti(θ::Vector, n)\n\nReturn a Multinomial  distribution object with number of trials n and success probabilities θ.\n\nThe mathematical form of the PMF for a Multinomial distribution in the BUGS family of softwares is given by:\n\nP(xnθ) = fracn_r x_r _r θ_r^x_r\n\nwhere x is a vector of length R representing the count of successes in each of R categories, n is the total number of trials, and θ is a vector of length R representing the probability of success in each of R categories. The symbol ∏ denotes the product over all categories.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SymbolicPPL is a graph-based probabilistic programming language and a component of the Turing ecosystem.  The package aims to support modelling and inference for probabilistic programs written in the BUGS language. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This project is still in its very early stage, with many key components needing to be completed. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please refer to the Github project page for usage information and a complete example.","category":"page"},{"location":"inference/#Inference-Tests","page":"Inference Tests","title":"Inference Tests","text":"","category":"section"},{"location":"inference/","page":"Inference Tests","title":"Inference Tests","text":"Currently, we still need a reliable inference infrastructure.  Users can try compiling into a Turing.Model and use the existing inference algorithms.  Although please note that many models may not work well, we are working on building the tools and optimizing performance. ","category":"page"},{"location":"bugs_lang/#BUGS-Language-Reference-(Under-Construction)","page":"BUGS Language Reference (Under Construction)","title":"BUGS Language Reference (Under Construction)","text":"","category":"section"},{"location":"bugs_lang/","page":"BUGS Language Reference (Under Construction)","title":"BUGS Language Reference (Under Construction)","text":"For now please refer to Model Specification.","category":"page"},{"location":"bugs_lang/#Notes-on-Modeling-with-BUGS","page":"BUGS Language Reference (Under Construction)","title":"Notes on Modeling with BUGS","text":"","category":"section"},{"location":"bugs_lang/","page":"BUGS Language Reference (Under Construction)","title":"BUGS Language Reference (Under Construction)","text":"We encourage users of the BUGS language first construct a model on paper. ","category":"page"},{"location":"bugs_lang/","page":"BUGS Language Reference (Under Construction)","title":"BUGS Language Reference (Under Construction)","text":"Every stochastic variable corresponds to a node in the graph, and every tilde assignment corresponds to the node's incoming edges.  The compiler will eagerly replace all the logical variables with their corresponding assignment.  Thus the compiled graph only contains stochastic variables.","category":"page"},{"location":"bugs_lang/","page":"BUGS Language Reference (Under Construction)","title":"BUGS Language Reference (Under Construction)","text":"Users familiar with programming languages like Julia should be warned that BUGS's array and loop syntax differs from Julia's.  In BUGS, loops do not represent the control flow but a shorthand to write programs for the unrolled version of the program.","category":"page"}]
}
