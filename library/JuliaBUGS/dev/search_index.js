var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"abs\ncloglog\nequals\nexp\ninprod\ninverse\nlog\nlogdet\nlogfact\nloggam\nicloglog\nlogit\nmexp\nmax\nmean\nmin\nphi\npow\nsqrt\nrank\nranked\nround\nsd\nsoftplus\nsort\n_step\nsum\ntrunc\nsin\narcsin\narcsinh\ncos\narccos\narccosh\ntan\narctan\narctanh","category":"page"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.abs","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.abs","text":"abs(x)\n\nAbsolute value of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.cloglog","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.cloglog","text":"cloglog(x)\n\nComplementary log-log function of x. Can be used as link function.\n\ncloglog(x) = log(-log(1 - x))\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.equals","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.equals","text":"equals(x, y)\n\nReturns 1 if x is equal to y, 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.exp","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.exp","text":"exp(x)\n\nExponential of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.inprod","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.inprod","text":"inprod(a, b)\n\nInner product of a and b.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.inverse","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.inverse","text":"inverse(v)\n\nInverse of matrix v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.log","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.log","text":"log(x)\n\nNatural logarithm of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logdet","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logdet","text":"logdet(v)\n\nLogarithm of the determinant of matrix v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logfact","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logfact","text":"logfact(x)\n\nLogarithm of the factorial of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.loggam","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.loggam","text":"loggam(x)\n\nLogarithm of the gamma function of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.icloglog","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.icloglog","text":"icloglog(x)\n\nInverse complementary log-log function of x. Alias for cexpexp(x).\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.logit","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.logit","text":"logit(x)\n\nLogit function of x. \n\nlogit(x) = log(x  (1 - x))\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.mexp","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.mexp","text":"mexp(x)\n\nMatrix exponential of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.max","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.max","text":"max(args...)\n\nReturn the maximum value of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Statistics.mean","page":"Functions","title":"Statistics.mean","text":"mean(v::AbstractVector)\n\nReturn the mean of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.min","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.min","text":"min(args...)\n\nReturn the minimum value of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.phi","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.phi","text":"phi(x)\n\nCumulative distribution function (CDF) of the standard normal distribution evaluated at x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.pow","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.pow","text":"pow(a, b)\n\nReturn a raised to the power of b.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sqrt","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sqrt","text":"sqrt(x)\n\nReturn the square root of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.rank","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.rank","text":"rank(v::AbstractVector, i::Int)\n\nReturn the rank of the i-th element of v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.ranked","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.ranked","text":"ranked(v::Vector, i::Int)\n\nReturn the i-th element of v sorted in ascending order.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.round","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.round","text":"round(x)\n\nRound x to the nearest integer.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sd","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sd","text":"sd(v::Vector)\n\nReturn the standard deviation of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.softplus","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.softplus","text":"softplus(x)\n\nReturn the softplus function of x, defined as log(1 + exp(x)).\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sort","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sort","text":"sort(v::Vector)\n\nReturn a sorted copy of the input vector v.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives._step","page":"Functions","title":"JuliaBUGS.BUGSPrimitives._step","text":"_step(x)\n\nReturn 1 if x is greater than 0, and 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sum","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sum","text":"sum(args...)\n\nReturn the sum of the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.trunc","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.trunc","text":"trunc(x)\n\nReturn the integer part of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.sin","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.sin","text":"sin(x)\n\nReturn the sine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arcsin","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arcsin","text":"arcsin(x)\n\nReturn the arcsine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arcsinh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arcsinh","text":"arcsinh(x)\n\nReturn the inverse hyperbolic sine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.cos","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.cos","text":"cos(x)\n\nReturn the cosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arccos","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arccos","text":"arccos(x)\n\nReturn the arccosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arccosh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arccosh","text":"arccosh(x)\n\nReturn the inverse hyperbolic cosine of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.tan","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.tan","text":"tan(x)\n\nReturn the tangent of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arctan","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arctan","text":"arctan(x)\n\nReturn the arctangent of x.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuliaBUGS.BUGSPrimitives.arctanh","page":"Functions","title":"JuliaBUGS.BUGSPrimitives.arctanh","text":"arctanh(x)\n\nReturn the inverse hyperbolic tangent of x.\n\n\n\n\n\n","category":"function"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Compile","page":"API","title":"Compile","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"compile","category":"page"},{"location":"api/#JuliaBUGS.compile","page":"API","title":"JuliaBUGS.compile","text":"compile(model_def[, data, initializations])\n\nCompile a BUGS model into a log density problem.\n\nArguments\n\nmodel_def::Expr: The BUGS model definition.\ndata::NamedTuple or Dict: The data to be used in the model. If none is passed, the data will be assumed to be empty.\ninitializations::NamedTuple or Dict: The initial values for the model parameters. If none is passed, the parameters will be assumed to be initialized to zero.\n\nReturns\n\nA BUGSModel object representing the compiled model.\n\n\n\n\n\n","category":"function"},{"location":"ast/#How-does-@bugsast-work?","page":"Parser Implementation","title":"How does @bugsast work?","text":"","category":"section"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"We provide a macro solution allowing users to directly use Julia code that corresponds to BUGS code:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"@bugsast begin\n    for i in 1:N\n        Y[i] ~ dnorm(μ[i], τ)\n        μ[i] = α + β * (x[i] - x̄)\n    end\n    τ ~ dgamma(0.001, 0.001)\n    σ = 1 / sqrt(τ)\n    logτ = log(τ)\n    α = dnorm(0.0, 1e-6)\n    β = dnorm(0.0, 1e-6)\nend","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"BUGS syntax carries over almost one-to-one to Julia.","category":"page"},{"location":"ast/#Internal-Macro-Structure","page":"Parser Implementation","title":"Internal Macro Structure","text":"","category":"section"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"The macro checks that only allowed syntactic forms are used and then applies some minor normalizations. The most prominent normalization is the conversion of stochastic statements (tildes) from :call expressions to first-class forms:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"quote\n    for i = 1:N\n        $(Expr(:~, :(Y[i]), :(dnorm(μ[i], τ))))\n        μ[i] = α + β * (x[i] - x̄)\n    end\n    $(Expr(:~, :τ, :(dgamma(0.001, 0.001))))\n    σ = 1 / sqrt(τ)\n    logτ = log(τ)\n    α = dnorm(0.0, 1.0e-6)\n    β = dnorm(0.0, 1.0e-6)\nend","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"In addition, there is a string macro bugsmodel which should work with the original (R-like) BUGS syntax:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"bugsmodel\"\"\"\n    for (i in 1:5) {\n        y[i] ~ dnorm(mu[i], tau)\n        mu[i] <- alpha + beta*(x[i] - mean(x[]))\n    }\n    \n    alpha ~ dflat()\n    beta ~ dflat()\n    tau <- 1/sigma2\n    log(sigma2) <- 2*log.sigma\n    log.sigma ~ dflat()\n\"\"\"","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"Internally, this macro applies a couple of regex-based substitutions to convert the code to the equivalent Julia, uses Meta.parse to parse the result, and applies the same logic as @bugsast. We encourage users to write new programs using the Julia-native syntax for better debuggability and perks like syntax highlighting. However, in the case of testing out legacy programs, using the macro should work for copy-paste situations. All variable names are preventively wrapped in var-strings; this allows R-style names like b.abd.","category":"page"},{"location":"ast/#AST-Structure","page":"Parser Implementation","title":"AST Structure","text":"","category":"section"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"The core forms which translate from BUGS to Julia are preserved in the equivalent Julia Exprs (e.g., :call, :for, :if, :=, :ref). The resulting code aims to be as close to executable as possible. Special forms are converted to simplify pattern matching:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"~ statements are parsed as :call by Julia, and get their own form (dc[i] ~ dunif(0, 20) → (:~, (:ref, :dc, :i), (:call, :dunif, 0, 20))).\nIn logical assignments with link functions, the block on the right-hand side, automatically created by the Julia parser, is removed. The result is therefore an := expression with a direct :call on the LHS.\nCensoring and truncation annotations are converted to :censored and :truncated forms (dnorm(x, μ) C (, 10) → (:censored, (:call, :dnorm, :x, :μ), :nothing, 100)). The left-out limits (C (, 100)) are filled with nothing. In @bugsast, you may just use normal calls truncated(dist, l, r) and censored(dist, l, r), which will be raised to special forms automatically.\nEmpty ranges are automatically filled with slices (x[,] → (:ref, :x, :(:), :(:))).","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"In addition, forms that have both a :call representation and their own lowered form are tried to be normalized to the latter; currently, this concerns getindex to :ref, and : to :(:).  LineNumberNodes are stripped completely.","category":"page"},{"location":"ast/#Advanced-Usage-for-Hackers","page":"Parser Implementation","title":"Advanced Usage for Hackers","text":"","category":"section"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"It should be reasonably easy to define anything else on top of this representation by using simple if statements and Meta.isexpr. Interpolation ($(…)) is allowed in @bugsast; the result of the macro is a :quote expression, in which the interpolations are just left as is. For example:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"@bugsast begin\n    x = $(myfunc(somevalue))\nend","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"This will end up as:","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"quote\n    x = $(myfunc(somevalue))\nend","category":"page"},{"location":"ast/","page":"Parser Implementation","title":"Parser Implementation","text":"With quasi-quotation working as usual, this allows for even greater flexibility and customization. However, be cautious when using interpolation, as it may be possible to construct ASTs that bypass validation and do not correspond to valid BUGS programs, so use it with care.","category":"page"},{"location":"graph/#Node-Function","page":"-","title":"Node Function","text":"","category":"section"},{"location":"graph/","page":"-","title":"-","text":"A node function for a stochastic variable is required to such that, when evaluate with the input arguments, returns a Distribution object that can be scored. Because the input can be arbitrary, a general node function can be very powerful. For instance, a mixture model can be represented by","category":"page"},{"location":"graph/","page":"-","title":"-","text":"function node_f(t, μ_1, μ_2, σ_1, σ_2)\n    if t >= 4\n        return Normal(μ_1, σ_1)\n    else\n        return Normal(μ_2, σ_2)\n    end\nend","category":"page"},{"location":"graph/","page":"-","title":"-","text":"where t is the input argument and μ_1, μ_2, σ_1, σ_2 are the parameters of the mixture model.","category":"page"},{"location":"graph/#Plotting","page":"-","title":"Plotting","text":"","category":"section"},{"location":"graph/","page":"-","title":"-","text":"A good way to debug a model is plotting the Bayesian Network.  We recommend using the TikzGraphs package to plot the Bayesian Network.  The following code shows how to plot the Bayesian Network of the model in the previous section.  Please note that the following code requires local latex environment to work.  For more information regarding installation and more advanced usage of TikzGraphs, please refer to the TikzGraphs.jl.","category":"page"},{"location":"graph/","page":"-","title":"-","text":"expr = @bugsast begin\n    a ~ dnorm(0, 1)\n    b ~ dnorm(a, 1)\n    c ~ dnorm(a, b)\n    d ~ dnorm(a - b, c)\nend\ng = compile(expr, (b=2.0, c=3.0), (a=1.0, d=4.0))\n\nusing TikzGraphs, TikzPictures\nimport TikzGraphs: plot\nusing Graphs, MetaGraphsNext\nusing AbstractPPL\n\nfunction plot(graph::BUGSGraph, parameters::Vector{VarName})\n    color_dict = Dict{Int, String}()\n    for (i, node) in enumerate(labels(graph))\n        if node in parameters\n            color_dict[i] = \"fill=green!10\"\n        else\n            color_dict[i] = \"fill=yellow!10\"\n        end\n    end\n\n    TikzGraphs.plot(\n        graph.graph, \n        map(x->String(Symbol(x)), labels(graph)), \n        node_style=\"draw, rounded corners, fill=blue!10\", \n        node_styles=color_dict,\n        edge_style=\"black\"\n    )\nend","category":"page"},{"location":"graph/#Providing-observations-for-parameters-of-the-model-will-break-the-dependencies","page":"-","title":"Providing observations for parameters of the model will break the dependencies","text":"","category":"section"},{"location":"graph/","page":"-","title":"-","text":"E.g.","category":"page"},{"location":"graph/","page":"-","title":"-","text":"model_def = @bugast begin\n    a ~ Normal(0, 1)\n    b ~ Normal(0, 1)\n    c ~ Normal(a, b)\nend\n\ndata = (a=1.0, b=2.0)","category":"page"},{"location":"graph/","page":"-","title":"-","text":"the generated graph in this case will not contain edges a -> c and b -> c. And node function of c will be c ~ Normal(1.0, 2.0). Ancestral sampling in this model will not sample a and b and will only sample c from Normal(1.0, 2.0). This behavior suggests that the model is constructed with the model definition and the data. Given different data, the model constructed may have different behaviors.","category":"page"},{"location":"misc/#BUGS-DevMan-Notes","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"","category":"section"},{"location":"misc/#Lexing","page":"BUGS DevMan Notes","title":"Lexing","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The BUGS language has the convention that if a name is followed","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"immediately by a round bracket, that is by a \"(\", then the names is a reserved name in the BUGS language and does not represent a variable in the model.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"By scanning the stream of tokens that constitute a BUGS language model the names of all the variables in the model can be found.","category":"page"},{"location":"misc/#A-BUGS-program-is-only-complete-when-presented-with-data","page":"BUGS DevMan Notes","title":"A BUGS program is only complete when presented with data","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The data will be used in the compilation process, including values of variables and shape of variables.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Maybe in the future we can support grabbing variables from Julia Runtime","category":"page"},{"location":"misc/#Table-of-Names","page":"BUGS DevMan Notes","title":"Table of Names","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The BUGS language compiler expands all the for loops in the model and records the value of the indices of each use of a tensor on the left hand side of each relation.\nThe range of each index, for a tensor, is set at the maximum value observed value of the index and added to the name table. There is one exception to this procedure for finding index bounds: names that are data, that is in the data source, have the ranges of their indices fixed in the data source.\nEach scalar and each component of a tensor used on the right hand side of a relation must occur either on the left hand side of a relation and or in a data source.","category":"page"},{"location":"misc/#Data-Transformations","page":"BUGS DevMan Notes","title":"Data Transformations","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"If the compiler can prove that a logical assignment can be evaluated to a constant then the assignment is called a data transformation. This occurs if an assignment's right hand side does not depend on any variable quantities. The BUGS language has a general rule that there must only be one assignment statement for each scalar or component of a tensor. This rule is slightly relaxed for data transformations. The language allows a logical assignment and a stochastic assignment to the same scalar or tensor component if and only if the logical assignment is a data transformation. ","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Possible optimization: do the data transformation first","category":"page"},{"location":"misc/#Generated-Quantities","page":"BUGS DevMan Notes","title":"Generated Quantities","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Only need to be evaluated after the inference algorithm has finished its task. ","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Generally, these are leaf nodes that logical variables\nIn the case of stochastic variables that are leaf nodes, do “forward sampling”, also part of the generated Quantities","category":"page"},{"location":"misc/#Computation","page":"BUGS DevMan Notes","title":"Computation","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"All the nodes in the graphical model representing logical relations are placed into an","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"array and sorted by their nesting level with the first array entries only depending on quantities defined by stochastic relations. Traversing this array and evaluating nodes gives up to date values to all logical relations.","category":"page"},{"location":"misc/#Types","page":"BUGS DevMan Notes","title":"Types","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The BUGS compiler uses the properties of the distribution on the right-hand side of a stochastic assignment statement to make deductions about the variable on the left-hand side. For example, r ~ dbin(p, n) implies that r is integer-valued, while x ~ dnorm(mu, tau) implies that x is real-valued.Some distributions are real-valued but have support on a restricted range of the reals. For example, p ~ dbeta(a, b) implies that p is real-valued with support on the unit interval, while x ~ dgamma(r, lambda) implies that x is real-valued but with support on the positive real line.There are two multivariate distributions in the BUGS language, the Dirichlet and the Wishart, that have support on a complex subspace of the reals. The Dirichlet has support on the unit simplex, while the Wishart has support on symmetric positive definite matrices.The BUGS compiler tries to infer if logical relations return an integer value by looking at whether their parents are integer-valued and the operators that combine the values of their parents into the return value. For example, in the cure model example above, the logical relation state1[i] <- state[i] + 1 is integer-valued because state[i] is a Bernoulli variable and therefore integer, the literal 1 is integer, and the sum of two integers is an integer.When the BUGS system reads in data from a data source, it can tag whether the number read is an integer or a real and propagate this information to logical relations. Again, using the cure model as an example, the statement t[i] <- x[i] + y[i] is integer-valued because both x and y are data and are given as integers in the data source.One special type of data is constants: that is just numbers with no associated distribution. Constants have many uses in BUGS language models, but one of the most important is as covariates. A model can contain a large number of constants that are used as covariates. Because of the possible large numbers of these covariate-type constants, they are given special treatment by the BUGS compiler. If a name read in from a data source is only used on the right-hand side of logical relations, no nodes in the graphical model are created to hold its values; they are directly incorporated in the objects that represent the right-hand sides of the logical relations.For example, the large Methadone model contains the regression:mu.indexed[i] <- beta[1] * x1[i] + beta[2] * x2[i] + beta[3] * x3[i] + beta[4] * x4[i] + region.effect[region.indexed[i]] + source.effect[region.indexed[i]] * source.indexed[i] + person.effect[person.indexed[i]]where i ranges from 1 to 240776. Not having to create a node in the graphical model to represent x1, x2, x3, x4, region.indexed, source.index, and person.indexed saves a large amount of space.In the BUGS language, the type information is fine-grained: each component of a tensor can have different type information. This is quite distinct from the situation in STAN and can make it much easier to specify a statistical model. One common case is where some components of a tensor have been observed while other components need to be estimated. The STAN documentation suggests workarounds for these situations, but these are somewhat complex.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The type propagation is interesting and maybe useful. But we don’t necessarily need to implement a type system. A dirty way to get type information is simply do a dry run with some tricks.","category":"page"},{"location":"misc/#Work-flow","page":"BUGS DevMan Notes","title":"Work flow","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The statistical model and data are presented to the BUGS system in a series of stages. In the first stage the model text is parsed into a tree and the name table constructed. The data is then loaded and checked against the model. The data can be split over a number of source. Once all the data has been loaded the model is compiled. Compiling builds the graphical model and does a large number of checks on the consistency of the model. Finally initial values can be given or generated for the model.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The compiler creates a node in the graphical model for each scalar name and each component of a tensor name in the BUGS language model. The compiler checks that only one node is created for each scalar name or component of a tensor name.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Reading in a data source causes the compiler to create special nodes called constant nodes to hold the values of the data.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The compiler processes logical relations before stochastic relations. Any logical relations that only have constant nodes on their right hand side become new constant nodes with the appropriate fixed value. Even if a logical relation can not be reduced to a constant some parts of the relation might be reduced to constants.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"Any constant nodes that have an associated stochastic relation become data nodes in the graphical model.","category":"page"},{"location":"misc/#Logical-relations-in-the-BUGS-Language","page":"BUGS DevMan Notes","title":"Logical relations in the BUGS Language","text":"","category":"section"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The OpenBUGS software compiles a description of a statistical model in the BUGS language into a graph of objects. Each relation in the statistical model gives rise to a node in the graph of objects. Each distinct type of relation in the statistical model is represented by a node of a distinct class. For stochastic relations there is a fixed set of distributions that can be used in the modelling. For logical relations the situation is more complex. The software can use arbitrary logical expressions build out of a fixed set of basic operators and functions. For each distinct logical expression a new software source code module is written to implement a class to represent that logical expression in the graph of objects. The software module is then compiled using the Components Pascal compiler and the executable code merged into the running OpenBUGS software using the run time loading linker.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The BUGS language description of a statistical model is parsed into a list of trees. The sub-trees that represent logical relations in the statistical model are first converted into a stack based representation and then into Component Pascal source code. The source code is generated in module BugsCPWrite and the source code is then compiled in module BugsCPCompiler. Usually the generated source code is not displayed. Checking the Verbose option in the Info menu will cause each each source code module generated by the OpenBUGS software to be displayed in a separate window.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"One advantage of a stack based representation of an expression is that it is straight forward to use it to derive source code that calculates the derivative of the expression with respect to its arguments. This part of the source code generation is carried out in module BugsCPWrite in procedure WriteEvaluateDiffMethod. Each operator in the stack representation of the logical expression causes a snippet of Component Pascal code to be written. These code snippets are generally very simple with those of binary operators slightly more complex than those of unitary operators. Each binary operators can emit three different code snippets: the general case and two special snippets depending on whether the left or right operands are numerical constants. The only complex code snippet is when an operand that is a logical relation in the statistical model is pushed onto the stack – the case of nested logical relations. In this case the nested logical relation will have its own code to calculate derivatives and these values can be passed up the nesting level.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The OpenBUGS software now uses a backward mode scheme to calculate the value of logical nodes in the statistical model. All the logical nodes in the statistical model are held in a global array and sorted according to their nesting level with unnested nodes at the start of the array. To evaluate all the logical nodes in the statistical model this array is then traversed and each logical node evaluated and the value stored in the node. The same scheme is used to calculate derivatives.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The graphs derived from the BUGS language representation of statistical models are generally sparse. The OpenBUGS software uses conditional independence arguments to exploit sparsity in the stochastic parts of the model. There is also a sparsity structure in logical relations.Each logical relation will often depend on just a few stochastic parents and derivatives with respect to other stochastic nodes in the model will be structurally zero. Each logical node has an associated array of stochastic parents for which the derivatives are non zero. Moving up the level of nesting the number of parents can grow. Dealing with this issue leads to the complexity in the code snippet for the operator that pushes a logical node onto the stack. These issues can be seen in the non-linear random effects model called Orange trees in volume II of the OpenBUGS examples. In this model eta[i,] is a function of phi[i,1], phi[i,2] and phi[i,3] where the phi are also logical functions of the stochastic theta[i,].","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"One refinement of the backward mode scheme used to calculate the value of logical nodes is to consider separately any logical nodes in the statistical model which are only used for prediction and do not affect the calculation of the joint probability distribution. These nodes need only be evaluated once per iteration of the inference algorithm. Examples of such nodes are sigma[k] and sigma.C in the Orange trees example. There is no need to evaluate the derivatives of these prediction nodes.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The workings of the backward mode scheme are easy to visualize when the inference algorithm updates all the stochastic nodes in the statistical model in one block. Local versions of the backward mode scheme can be used when the inference algorithm works on single nodes or when a small blocks of nodes are updated. Each stochastic node is given its own vector of logical nodes that depend on it either directly or via other logical nodes and this vector is sorted by nesting level. Each updater that works on small blocks of nodes contains a vector of logical nodes which is the union of the vectors of dependent logical nodes for each of its components.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The idea of the backward mode scheme for evaluating logical nodes can be used with caching in Metropolis Hastings sampling. First the vector of logical nodes depending on the relevant stochastic node(s) is evaluated and their values cached. The log of the conditional distribution is then calculated. Next a new value of the stochastic node is proposed. The vector of logical nodes is re-evaluated and the log of the conditional distribution calculated. If the proposed value is rejected then the cache is used to set the vector of logical nodes back to its old values.","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"The OpenBUGS software also calculates what class of function each logical node is in terms of its stochastic parents. If the software can prove for example that a logical node is a linear function of its parents more efficient sampling algorithms can be used. If a linear relation can be proved then the calculation of derivatives can also be optimized in some cases because they will be constant and so only need to be calculated once. Generalized linear models are implemented in a way that allows fast calculation of derivatives. The structure of the algorithm to classify the functional form of logical nodes is very similar to that for derivatives and uses a backward mode scheme","category":"page"},{"location":"misc/","page":"BUGS DevMan Notes","title":"BUGS DevMan Notes","text":"BUGS separates management of logical and stochastic variables, essentially two graphs. Logical variables are stored in an array and values are updated with values in earlier positions of the array.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dnorm\ndlogis\ndt\nTDistShiftedScaled\nddexp\ndflat\nFlat\nTruncatedFlat\ndexp\ndchisqr\ndweib\ndlnorm\ndgamma\ndpar\ndgev\ndgpar\ndf\ndunif\ndbeta\ndmnorm\ndmt\ndwish\nddirich\ndbern\ndbin\ndcat\ndpois\ndgeom\ndnegbin\ndbetabin\ndhyper\ndmulti","category":"page"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dnorm","text":"dnorm(μ, τ)\n\nConstruct a Normal  distribution object in Julia using mean μ and precision τ as parameters. \n\nIn many statistical contexts, including the BUGS family of software, the Normal distribution is parametrized using precision, which is defined as the reciprocal of the variance. In contrast, Julia's Distributions package parametrizes the Normal distribution using mean (μ) and standard deviation (σ). This function accepts the mean μ and precision τ as inputs, then calculates the standard deviation as σ = √(1 / τ), and returns a Normal distribution object with mean μ and standard deviation σ.\n\nThe probability density function (PDF) of the Normal distribution as defined in the BUGS family of software is:\n\np(xμτ) = sqrtfracτ2π e^-τ frac(x-μ)^22\n\nIn this equation, x is the random variable, μ is the mean of the distribution, and τ is the precision.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dlogis","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dlogis","text":"dlogis(μ, τ)\n\nReturn a Logistic  distribution object with location parameter μ and scale parameter s, where s = 1  τ.\n\nThe mathematical form of the PDF for a Logistic distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτ e^-sqrtτ(x-μ)(1+e^-sqrtτ(x-μ))^2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dt","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dt","text":"dt(μ, τ, ν)\n\nConstruct a Student's t-distribution object with ν degrees of freedom, location μ, and scale σ = (1  τ). \n\nIf μ is 0 and σ is 1, the function returns a TDist object from Distributions.jl. Otherwise, it returns a TDistShiftedScaled object.\n\nThe mathematical form of the PDF for a Student's t-distribution is given by:\n\np(xνμσ) = fracΓ((ν+1)2)Γ(ν2) νπσ\nleft(1+frac1νleft(fracx-μσright)^2right)^-fracν+12\n\nend\n\nThe mathematical form of the log-PDF for a Student's t-distribution is given by:\n\nlog(p(xνμσ)) = log(Γ((ν+1)2)) - log(Γ(ν2)) - frac12log(νπσ) - fracν+12 logleft(1+frac1νleft(fracx-μσright)^2right)\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.TDistShiftedScaled","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.TDistShiftedScaled","text":"TDistShiftedScaled(ν, μ, σ)\n\nA Student's t-distribution object with ν degrees of freedom, location μ, and scale σ. \n\nThis struct allows for a shift (determined by μ) and a scale (determined by σ) of the standard Student's t-distribution provided by the Distributions package. \n\nOnly pdf and logpdf are implemented for this distribution.\n\nSee Also\n\nTDist\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.ddexp","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.ddexp","text":"ddexp(μ, τ)\n\nReturn a Laplace (Double Exponential)  distribution object with location μ and scale b = 1  τ.\n\nThe mathematical form of the PDF for a Laplace distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτ2 e^-sqrtτ x-μ\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dflat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dflat","text":"dflat()\n\nA distribution type representing a flat (uniform) prior over the real line. This is not a valid probability distribution, but can be used to represent a non-informative prior in Bayesian statistics. The cdf, logcdf, quantile, cquantile, rand, and rand methods are not implemented for this distribution, as they don't have meaningful definitions in the context of a flat prior. When use in a model, the parameters always need to be initialized to a valid value.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.Flat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.Flat","text":"Flat\n\nImplement the flat distribution mimicking the behavior of the dflat distribution in the BUGS family of softwares.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.TruncatedFlat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.TruncatedFlat","text":"TruncatedFlat\n\nTruncated version of the flat distribution.\n\n\n\n\n\n","category":"type"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dexp","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dexp","text":"dexp(λ)\n\nReturn an Exponential  distribution object with rate λ, where the rate is defined as 1  λ in Julia's Distributions package.\n\nThe mathematical form of the PDF for an Exponential distribution in the BUGS family of softwares is given by:\n\np(xλ) = λ e^-λ x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dchisqr","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dchisqr","text":"dchisqr(k)\n\nReturn a Chi-squared  distribution object with k degrees of freedom.\n\nThe mathematical form of the PDF for a Chi-squared distribution in the BUGS family of softwares is given by:\n\np(xk) = frac12^k2 Γ(k2) x^k2 - 1 e^-x2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dweib","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dweib","text":"dweib(a, b)\n\nReturn a Weibull  distribution object with shape parameter a and scale parameter λ = 1  b.\n\nThe Weibull distribution is a common model for event times. The hazard or instantaneous risk of the event is (h(x) = abx^{a-1}). For a < 1 the hazard decreases with x; for a > 1 it increases. a = 1 results in the exponential distribution with constant hazard.\n\nThe mathematical form of the probability density function (PDF) for a Weibull distribution in the BUGS family of softwares is given by:\n\np(xab) = abx^a-1e^-b x^a\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dlnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dlnorm","text":"dlnorm(μ, τ)\n\nReturn a LogNormal  distribution object with location μ and scale σ = 1  τ.\n\nThe mathematical form of the PDF for a LogNormal distribution in the BUGS family of softwares is given by:\n\np(xμτ) = fracsqrtτxsqrt2π e^-τ2 (log(x) - μ)^2\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgamma","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgamma","text":"dgamma(a, b)\n\nReturn a Gamma  distribution object with shape a and scale θ = 1  b.\n\nThe mathematical form of the PDF for a Gamma distribution in the BUGS family of softwares is given by:\n\np(xab) = fracb^aΓ(a) x^a-1 e^-bx\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dpar","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dpar","text":"dpar(a, b)\n\nReturn a Pareto  distribution object with scale parameter b and shape parameter a.\n\nThe Pareto distribution, also known as the \"80-20 rule\", states that for many events, roughly 80% of the effects come from 20% of the causes. In terms of wealth distribution, it's often observed that 20% of the population owns 80% of a society's wealth. \n\nThe mathematical form of the probability density function (PDF) for a Pareto distribution in the BUGS family of softwares is given by:\n\np(xab) = fraca b^ax^a+1\n\nIn Julia, this function uses scale parameter b and shape parameter a to construct a Pareto(b, a) distribution object from the Distributions package.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgev","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgev","text":"dgev(μ, σ, η)\n\nReturn a GeneralizedExtremeValue  distribution object with location μ, scale σ, and shape η.\n\nThe mathematical form of the PDF for a Generalized Extreme Value distribution in the BUGS family of softwares is given by:\n\np(xμση) = frac1σ left(1 + η fracx - μσright)^-frac1η - 1 e^-left(1 + η fracx - μσright)^-frac1η\n\nwhere x is the random variable, μ is the location parameter, σ is the scale parameter, and η is the shape parameter. Note that the expression 1 + η ((x - μ)/σ) must be greater than zero for the function to be defined.\n\nIn Julia, this function returns a GeneralizedExtremeValue(μ, σ, η) distribution object from the Distributions package.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgpar","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgpar","text":"dgpar(μ, σ, η)\n\nReturn a GeneralizedPareto  distribution object with location μ, scale σ, and shape η.\n\nThe mathematical form of the PDF for a Generalized Pareto distribution in the BUGS family of softwares is given by:\n\np(xμση) = frac1σ (1 + η ((x - μ)σ))^-1η - 1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.df","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.df","text":"df(n::Real, m::Real, μ::Real=0, τ::Real=1)\n\nReturn an F-distribution  object with n and m degrees of freedom, location μ, and scale τ. Raises a warning if μ ≠ 0 or τ ≠ 1, as these cases are not fully supported.\n\nThe mathematical form of the PDF for an F-distribution in the BUGS family of softwares is given by:\n\np(xn m μ τ) = fracGammaleft(fracn+m2right)Gammaleft(fracn2right) Gammaleft(fracm2right) left(fracnmright)^fracn2 sqrtτ left(sqrtτ(x - μ)right)^fracn2-1 left(1 + fracn sqrtτ(x-μ)mright)^-fracn+m2\n\nwhere x is the random variable, n and m are the degrees of freedom, μ is the location parameter, and τ is the scale parameter. Note that the expression 1 + n sqrt(τ)(x - μ) / m must be greater than zero for the function to be defined.\n\nIn Julia, this function returns an FDist(n, m) distribution object from the Distributions package if μ = 0 and τ = 1.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dunif","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dunif","text":"dunif(a, b)\n\nReturn a Uniform  distribution object with lower bound a and upper bound b.\n\nThe mathematical form of the PDF for a Uniform distribution in the BUGS family of softwares is given by:\n\np(xab) = frac1b - a\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbeta","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbeta","text":"dbeta(a, b)\n\nReturn a Beta  distribution object with shape parameters a and b.\n\nThe mathematical form of the PDF for a Beta distribution in the BUGS family of softwares is given by:\n\np(xab) = fracGamma(a + b)Gamma(a)Gamma(b) x^a-1 (1 - x)^b-1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmnorm","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmnorm","text":"dmnorm(μ::Vector, T::Matrix)\n\nReturn a Multivariate Normal  distribution object with mean vector μ and precision matrix T.\n\nThe mathematical form of the PDF for a Multivariate Normal distribution in the BUGS family of softwares is given by:\n\np(xμT) = (2π)^-k2 T^12 e^-12 (x-μ) T (x-μ)\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmt","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmt","text":"dmt(μ::Vector, T::Matrix, k)\n\nReturn a Multivariate T  distribution object with mean vector μ, precision matrix T, and k degrees of freedom.\n\nThe mathematical form of the PDF for a Multivariate T distribution in the BUGS family of softwares is given by:\n\np(xkμΣ) = fracGamma((k+p)2)Gamma(k2) (kpi)^p2 Σ^12 left(1 + frac1k (x-μ)^T Σ^-1 (x-μ)right)^-frack+p2\n\nwhere x is the random variable, k is the degrees of freedom, μ is the mean vector, Σ is the scale matrix, and p is the dimension of x.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dwish","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dwish","text":"dwish(R::Matrix, k)\n\nReturn a Wishart  distribution object with k degrees of freedom and scale matrix R^(-1).\n\nThe mathematical form of the PDF for a Wishart distribution in the BUGS family of softwares is given by:\n\np(XRk) = X^(k-p-1)2 e^-12 tr(RX)  (2^kp2 R^k2 Γ_p(k2))\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.ddirich","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.ddirich","text":"ddirich(θ::Vector)\n\nReturn a Dirichlet  distribution object with parameters θ.\n\nThe mathematical form of the PDF for a Dirichlet distribution in the BUGS family of softwares is given by:\n\np(xθ) = fracΓ(sum θ) Γ(θ)  x_i^θ_i - 1\n\nwhere x is a vector of random variables, each element x_i of which is between 0 and 1, and the elements of x sum up to 1. θ is a vector of parameters, each θ_i of which is greater than 0.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbern","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbern","text":"dbern(p)\n\nReturn a Bernoulli  distribution object with success probability p.\n\nThe mathematical form of the PMF for a Bernoulli distribution in the BUGS family of softwares is given by:\n\np(xp) = p^x (1 - p)^1-x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbin","text":"dbin(p, n)\n\nReturn a Binomial  distribution object with number of trials n and success probability p.\n\nThe mathematical form of the PMF for a Binomial distribution in the BUGS family of softwares is given by:\n\np(xnp) = binomnx p^x (1 - p)^n-x\n\nend\n\nwhere x is a random variable that can take the values from 0 to n.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dcat","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dcat","text":"dcat(p)\n\nReturn a Categorical  distribution object with probabilities p.\n\nThe mathematical form of the PMF for a Categorical distribution in the BUGS family of softwares is given by:\n\np(xp) = px\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dpois","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dpois","text":"dpois(θ)\n\nReturn a Poisson  distribution object with mean (and variance) θ.\n\nThe mathematical form of the PMF for a Poisson distribution in the BUGS family of softwares is given by:\n\np(xθ) = e^-θ θ^x  x\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dgeom","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dgeom","text":"dgeom(θ)\n\nReturn a Geometric  distribution object with success probability θ.\n\nThe mathematical form of the PMF for a Geometric distribution in the BUGS family of softwares is given by:\n\np(xθ) = (1 - θ)^x-1 θ\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dnegbin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dnegbin","text":"dnegbin(p, r)\n\nReturn a Negative Binomial  distribution object with number of failures r and success probability p.\n\nThe mathematical form of the PMF for a Negative Binomial distribution in the BUGS family of softwares is given by:\n\nP(xrp) = binomx + r - 1x (1 - p)^x p^r\n\nwhere x is a random variable that can take non-negative integer values.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dbetabin","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dbetabin","text":"dbetabin(a, b, n)\n\nReturn a Beta Binomial  distribution object with number of trials n and shape parameters a and b.\n\nThe mathematical form of the PMF for a Beta Binomial distribution in the BUGS family of softwares is given by:\n\nP(xa b n) = binomnx binoma + b - 1a + x - 1  binoma + b + n - 1n\n\nwhere x is the number of successful trials, n is the total number of trials, a and b are the shape parameters of the Beta distribution.\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dhyper","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dhyper","text":"dhyper(n1, n2, m1, ψ)\n\nReturn a Hypergeometric  distribution object. This distribution is used when sampling without replacement from a population consisting of  n1 successes and n2 failures, with m1 being the number of trials or the sample size.\n\nψ is a scaling parameter which is currently unsupported in this function. Only ψ = 1 is currently supported.\n\nThe mathematical form of the PMF for a Hypergeometric distribution in the BUGS family of softwares is given by:\n\np(x  n1 n2 m1 psi) = fracbinomn1x binomn2m1 - x psi^xsum_i=max(0 m1-n2)^min(n1m1) binomn1i binomn2m1 - i psi^i\n\nIn this formula, x is the number of successes in the sample, n1 is the total number of successes in the population, n2 is the total number of failures in the population, m1 is the number of trials, and \\psi is a scaling parameter.\n\nThe sum in the denominator is over i from u0 to u1, where\n\nu_0 = max(0 m1 - n2) quad u_1 = min(n1 m1) quad textand quad u_0 leq x leq u_1\n\n\n\n\n\n","category":"function"},{"location":"distributions/#JuliaBUGS.BUGSPrimitives.dmulti","page":"Distributions","title":"JuliaBUGS.BUGSPrimitives.dmulti","text":"dmulti(θ::Vector, n)\n\nReturn a Multinomial  distribution object with number of trials n and success probabilities θ.\n\nThe mathematical form of the PMF for a Multinomial distribution in the BUGS family of softwares is given by:\n\nP(xnθ) = fracn_r x_r _r θ_r^x_r\n\nwhere x is a vector of length R representing the count of successes in each of R categories, n is the total number of trials, and θ is a vector of length R representing the probability of success in each of R categories. The symbol ∏ denotes the product over all categories.\n\n\n\n\n\n","category":"function"},{"location":"using_r/#Using-R-in-Julia","page":"Using R in Julia","title":"Using R in Julia","text":"","category":"section"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"Julia has an easy-to-use interface to R. ","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"The RCall.jl package generally provides a Julia interface to R functions, and  the RData.jl package might be helpful for reading R data files.","category":"page"},{"location":"using_r/#Reading-BUGS-data-and-init-from-R-like-lists","page":"Using R in Julia","title":"Reading BUGS data and init from R like lists","text":"","category":"section"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"The example data and inits from BUGS can be read into Julia using the RCall.jl package. For example, the data from Rats provided in OpenBUGS can be found here.","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"In Julia, we can read this data into a Julia dictionary using the RCall.jl package.","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"julia> using RCall\n\njulia> data = R\"\nlist(\n    x = c(8.0, 15.0, 22.0, 29.0, 36.0), xbar = 22, N = 30, T = 5,\n    Y = structure(\n        .Data = c(\n            151, 199, 246, 283, 320,\n            145, 199, 249, 293, 354,\n            147, 214, 263, 312, 328,\n            155, 200, 237, 272, 297,\n            135, 188, 230, 280, 323,\n            159, 210, 252, 298, 331,\n            141, 189, 231, 275, 305,\n            159, 201, 248, 297, 338,\n            177, 236, 285, 350, 376,\n            134, 182, 220, 260, 296,\n            160, 208, 261, 313, 352,\n            143, 188, 220, 273, 314,\n            154, 200, 244, 289, 325,\n            171, 221, 270, 326, 358,\n            163, 216, 242, 281, 312,\n            160, 207, 248, 288, 324,\n            142, 187, 234, 280, 316,\n            156, 203, 243, 283, 317,\n            157, 212, 259, 307, 336,\n            152, 203, 246, 286, 321,\n            154, 205, 253, 298, 334,\n            139, 190, 225, 267, 302,\n            146, 191, 229, 272, 302,\n            157, 211, 250, 285, 323,\n            132, 185, 237, 286, 331,\n            160, 207, 257, 303, 345,\n            169, 216, 261, 295, 333,\n            157, 205, 248, 289, 316,\n            137, 180, 219, 258, 291,\n            153, 200, 244, 286, 324\n        ),\n        .Dim = c(30, 5)\n    )\n)\n\"\nRObject{VecSxp}\n$x\n[1]  8 15 22 29 36\n\n$xbar\n[1] 22\n\n$N\n[1] 30\n\n$T\n[1] 5\n\n$Y\n      [,1] [,2] [,3] [,4] [,5]\n [1,]  151  141  154  157  132\n [2,]  199  189  200  212  185\n [3,]  246  231  244  259  237\n [4,]  283  275  289  307  286\n [5,]  320  305  325  336  331\n [6,]  145  159  171  152  160\n [7,]  199  201  221  203  207\n [8,]  249  248  270  246  257\n [9,]  293  297  326  286  303\n[10,]  354  338  358  321  345\n[11,]  147  177  163  154  169\n[12,]  214  236  216  205  216\n[13,]  263  285  242  253  261\n[14,]  312  350  281  298  295\n[15,]  328  376  312  334  333\n[16,]  155  134  160  139  157\n[17,]  200  182  207  190  205\n[18,]  237  220  248  225  248\n[19,]  272  260  288  267  289\n[20,]  297  296  324  302  316\n[21,]  135  160  142  146  137\n[22,]  188  208  187  191  180\n[23,]  230  261  234  229  219\n[24,]  280  313  280  272  258\n[25,]  323  352  316  302  291\n[26,]  159  143  156  157  153\n[27,]  210  188  203  211  200\n[28,]  252  220  243  250  244\n[29,]  298  273  283  285  286\n[30,]  331  314  317  323  324","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"equivalently, reval(s::String) will produce the same result in this case.","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"If the data is stores in a file, user can use a function similar to","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"function read_rlist_to_dictionary(filepath::String)\n    r_data = open(filepath) do f\n        s = read(f, String)\n        reval(s)\n    end\n    return rcopy(r_data)\nend","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"User can save the result to a Julia variable and access the data as a Julia dictionary.","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"julia> rcopy(data)\nOrderedDict{Symbol, Any} with 5 entries:\n  :x    => [8.0, 15.0, 22.0, 29.0, 36.0]\n  :xbar => 22.0\n  :N    => 30.0\n  :T    => 5.0\n  :Y    => [151.0 141.0 … 157.0 132.0; 199.0 189.0 … 212.0 185.0; … ; 298.0 273.0 … 285.0 286.0; 331.0 314.0 … 323.0 324.0]","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"It is worth noting that rcopy will automatically convert data names contains . to _ in Julia. E.g.","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"julia> rcopy(R\"list(a.b = 1)\")\nOrderedDict{Symbol, Any} with 1 entry:\n  :a_b => 1.0","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"The issue here is that the data layout in BUGS assumes the data is stored in row-major order, while R stores data in column-major order. (Stan developers has worked out data and initializations of BUGS models in R, and can be found here)","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"If you want to load data using the R interface, but the data source is in the same layout as BUGS, you can process the data in Julia, for instance","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"# define a row-major reshape function, because Julia's `reshape` is column-major\njulia> function rreshape(v::Vector, dim)\n           return permutedims(reshape(v, reverse(dim)), length(dim):-1:1)\n       end   \nrreshape (generic function with 1 method)\n\njulia> rreshape(vcat(data[:Y]...), (30, 5))\n30×5 Matrix{Float64}:\n 151.0  199.0  246.0  283.0  320.0\n 145.0  199.0  249.0  293.0  354.0\n 147.0  214.0  263.0  312.0  328.0\n 155.0  200.0  237.0  272.0  297.0\n 135.0  188.0  230.0  280.0  323.0\n 159.0  210.0  252.0  298.0  331.0\n 141.0  189.0  231.0  275.0  305.0\n 159.0  201.0  248.0  297.0  338.0\n   ⋮                         \n 146.0  191.0  229.0  272.0  302.0\n 157.0  211.0  250.0  285.0  323.0\n 132.0  185.0  237.0  286.0  331.0\n 160.0  207.0  257.0  303.0  345.0\n 169.0  216.0  261.0  295.0  333.0\n 157.0  205.0  248.0  289.0  316.0\n 137.0  180.0  219.0  258.0  291.0\n 153.0  200.0  244.0  286.0  324.0","category":"page"},{"location":"using_r/","page":"Using R in Julia","title":"Using R in Julia","text":"User should be advised to verify the data layout before using the data.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaBUGS is a graph-based probabilistic programming language and a component of the Turing ecosystem.  The package aims to support modelling and inference for probabilistic programs written in the BUGS language. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This project is still in its very early stage, with many key components needing to be completed. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please refer to the Github project page for usage information and a complete example.","category":"page"},{"location":"#What-is-BUGS?","page":"Introduction","title":"What is BUGS?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The BUGS (Bayesian inference Using Gibbs Sampling) system is a probabilistic programming framework designed for specifying directed graphical models. Unlike certain other probabilistic programming languages (PPLs), such as Turing.jl or Pyro, the focus of BUGS is on specifying declarative relationships between nodes in a graph, which can be either logical or stochastic. This means that explicit declarations of variables, inputs, outputs, etc., are not required, and the order of statements is not critical.","category":"page"},{"location":"#The-BUGS-Approach-and-Benefits","page":"Introduction","title":"The BUGS Approach and Benefits","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Loops in BUGS are essentially a form of \"plate notation,\" offering a concise way to express repetitive statements across many constant indices. Variables in BUGS are either the names of nodes within the program or constant parts of the \"data\" that must be combined with a model for instantiation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A BUGS model provides a comprehensive representation of the relationships and dependencies among a set of variables within a Bayesian framework. Our goal is to support BUGS programs as much as possible while also incorporating Julia-specific syntax enhancements.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The key advantage of utilizing such a graph-based approach is the clarity it provides in understanding the dependencies and relationships within a complex system. These graphical models allow users to explicitly state the conditional dependencies between variables. This makes the model's structure and assumptions transparent, aiding both in the development and interpretation stages. Furthermore, using such a graphical approach makes it easier to apply advanced algorithms for model inference, as it enables more efficient computation by identifying and exploiting the structure of the model.","category":"page"}]
}
