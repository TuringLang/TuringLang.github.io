<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>AST Translation · JuliaBUGS.jl</title><script data-outdated-warner="" src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/><link href="../../../assets/multidoc-custom.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><div class="nav-dropdown"><button class="nav-item dropdown-label">Modelling languages</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../DynamicPPL/">DynamicPPL</a><a class="nav-link active nav-item" href="../../">JuliaBUGS</a><a class="nav-link nav-item" href="../../../TuringGLM/">TuringGLM</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">MCMC</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../AdvancedHMC/">AdvancedHMC</a><a class="nav-link nav-item" href="../../../AbstractMCMC/">AbstractMCMC</a><a class="nav-link nav-item" href="../../../ThermodynamicIntegration/">ThermodynamicIntegration</a><a class="nav-link nav-item" href="../../../AdvancedPS/">AdvancedPS</a><a class="nav-link nav-item" href="../../../EllipticalSliceSampling/">EllipticalSliceSampling</a><a class="nav-link nav-item" href="../../../NestedSamplers/">NestedSamplers</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Diagnostics</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../MCMCChains/">MCMCChains</a><a class="nav-link nav-item" href="../../../MCMCDiagnosticTools/">MCMCDiagnosticTools</a><a class="nav-link nav-item" href="../../../ParetoSmooth/">ParetoSmooth</a></ul></div><a class="nav-link nav-item" href="../../../Bijectors/">Bijectors</a><a class="nav-link nav-item" href="../../../TuringCallbacks/">TuringCallbacks</a><a class="nav-link nav-item" href="../../../TuringBenchmarking/">TuringBenchmarking</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Gaussian Processes</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../AbstractGPs/">AbstractGPs</a><a class="nav-link nav-item" href="../../../KernelFunctions/">KernelFunctions</a><a class="nav-link nav-item" href="../../../ApproximateGPs/">ApproximateGPs</a></ul></div><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding"></div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliaBUGS.jl</a></span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../bugs_lang/">BUGS Language Reference</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href="">AST Translation</a><ul class="internal"><li><a class="tocitem" href="#Syntax-and-model-representation"><span>Syntax &amp; model representation</span></a></li><li><a class="tocitem" href="#Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro"><span>Add New Functions – this should be replaced by the <code>@bugsfunction</code> macro</span></a></li><li><a class="tocitem" href="#Semantics"><span>Semantics</span></a></li></ul></li><li><a class="tocitem" href="../array/">Array Interface</a></li><li><a class="tocitem" href="../compilation_target/">Compilation Target</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">AST Translation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">AST Translation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/JuliaBUGS.jl/blob/master/docs/src/ast.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h2 id="Syntax-and-model-representation"><a class="docs-heading-anchor" href="#Syntax-and-model-representation">Syntax &amp; model representation</a><a id="Syntax-and-model-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax-and-model-representation" title="Permalink"></a></h2><p>We provide some convenience functions to work with graphical models syntactically in Julia, inspired very much by <a href="https://www.mrc-bsu.cam.ac.uk/software/bugs/">BUGS</a>. BUGS (Bayesian inference Using Gibbs Sampling), as the name says, is a probabilistic programming system originally designed for Gibbs sampling. For this purpose, BUGS models define, implicitly, only a directed graph of variables, not an ordered sequence of statements like other PPLs. They do have the advantage of being relatively restricted (while still able to express a very large class of practically used models), and hence allowing lots of static analysis.   Specifically, stochastic control flow is disallowed (except for the “mixture model” case of indexing by a stochastic variable, <strong>indexing with stochastic variable is not supported yet</strong>).</p><p>We provide a macro solution which allows to directly use Julia code corresponding to BUGS code:</p><pre><code class="language-julia hljs">@bugsast begin
    for i in 1:N
        Y[i] ~ dnorm(μ[i], τ)
        μ[i] = α + β * (x[i] - x̄)
    end
    τ ~ dgamma(0.001, 0.001)
    σ = 1 / sqrt(τ)
    logτ = log(τ)
    α = dnorm(0.0, 1e-6)
    β = dnorm(0.0, 1e-6)
end</code></pre><p>BUGS syntax carries over almost one-to-one to Julia. The macro checks that only allowed syntactic forms are used and then applies some minor normalizations. The most prominent normalization is the conversion of stochastic statements (tildes) from <code>:call</code> expressions to first-class forms:</p><pre><code class="language-julia hljs">quote
    for i = 1:N
        $(Expr(:~, :(Y[i]), :(dnorm(μ[i], τ))))
        μ[i] = α + β * (x[i] - x̄)
    end
    $(Expr(:~, :τ, :(dgamma(0.001, 0.001))))
    σ = 1 / sqrt(τ)
    logτ = log(τ)
    α = dnorm(0.0, 1.0e-6)
    β = dnorm(0.0, 1.0e-6)
end</code></pre><h2 id="Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro"><a class="docs-heading-anchor" href="#Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro">Add New Functions – this should be replaced by the <code>@bugsfunction</code> macro</a><a id="Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Add-New-Functions-–-this-should-be-replaced-by-the-@bugsfunction-macro" title="Permalink"></a></h2><p>It should be reasonably easy to define anything else on top of this representation by using simple <code>if</code> statements, and <code>Meta.isexpr</code>. Interpolation (<code>$(…)</code>) is allowed in <code>@bugsast</code>; the result of the macro is a <code>:quote</code> expression, in which the interpolations are just left as is. I.e.,</p><pre><code class="language-julia hljs">@bugsast begin
    x = $(myfunc(somevalue))
end</code></pre><p>will end up as </p><pre><code class="language-julia hljs">quote
    x = $(myfunc(somevalue))
end</code></pre><p>with quasi-quotation working as usual. (Using interpolation, it is possible to construct ASTs which bypass validation and do not correspond to valid BUGS programs – use it with care.)</p><p>In addition, there is a string macro <code>bugsmodel</code> which should work with original (R-like) BUGS syntax:</p><pre><code class="language-julia hljs">bugsmodel"""
    for (i in 1:5) {
        y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta*(x[i] - mean(x[]))
    }
    
    alpha ~ dflat()
    beta ~ dflat()
    tau &lt;- 1/sigma2
    log(sigma2) &lt;- 2*log.sigma
    log.sigma ~ dflat()
"""</code></pre><p>Internally, the only thing this does is apply a couple of regex-based substitutions to convert the code to the equivalent Julia, <code>Meta.parse</code> the result, and apply the same logic as <code>@bugsast</code>. We encourage users to write new program using the Julia-native syntax, because of better debuggability and perks like syntax highlighting.  But in the case of testing out legacy program, the macro upfront should work for copy-paste situations. All variable names are preventively wrapped in var-strings; this allows R-style names like <code>b.abd</code>.</p><h3 id="AST-structure"><a class="docs-heading-anchor" href="#AST-structure">AST structure</a><a id="AST-structure-1"></a><a class="docs-heading-anchor-permalink" href="#AST-structure" title="Permalink"></a></h3><p>Basically, all forms which obviously translate from BUGS to Julia are preserved in the equivalent Julia <code>Expr</code>s (<code>:call</code>, <code>:for</code>, <code>:if</code>, <code>:=</code>, <code>:ref</code>). The resulting code should be as close to executable as possible. Special forms are converted, though, in order to simplify pattern matching:</p><ul><li><code>~</code> statements are parsed as <code>:call</code> by Julia, and get their own form (<code>dc[i] ~ dunif(0, 20)</code> → <code>(:~, (:ref, :dc, :i), (:call, :dunif, 0, 20))</code>).</li><li>In logical assignments with link functions, the block on the right hand side, automatically created by the Julia parser, is removed. The result is therefore an <code>:=</code> expression with a direct <code>:call</code> on the LHS.</li><li>Censoring and truncation annoations are converted to <code>:censored</code> and <code>:truncated</code> forms (<code>dnorm(x, μ) C (, 10)</code> → <code>(:censored, (:call, :dnorm, :x, :μ), :nothing, 100)</code>). The left-out limits (<code>C (, 100)</code>) are filled with <code>nothing</code>. In <code>@bugsast</code>, you may just use normal calls <code>truncated(dist, l, r)</code> and <code>censored(dist, l, r)</code>, which will be raised to special forms automatically.</li><li>Empty ranges are automatically filled with slices (<code>x[,]</code> → <code>(:ref, :x, :(:), :(:))</code>).</li></ul><p>In addition, forms that have both a <code>:call</code> representation and their own lowered form are tried to be normalized to the latter; currently, this concerns <code>getindex</code> to <code>:ref</code>, and <code>:</code> to <code>:(:)</code>.  <code>LineNumberNode</code>s are stripped completely.</p><h2 id="Semantics"><a class="docs-heading-anchor" href="#Semantics">Semantics</a><a id="Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Semantics" title="Permalink"></a></h2><p>The semantics of BUGS are not really made explicit.  I have tried to "reconstruct" a formalization and type system, but this is still ongoing work.</p><p>BUGS programs, in contrast to some other PPLs, have the sole purpose of implicitly describing a directed graphical model. This means that they don’t really have operational semantics – there are not declarations of variables, input, outputs, etc., nor is order relevant. A program like</p><pre><code class="nohighlight hljs">model
{
  for( i in 1 : N ) {
    for( j in 1 : T ) {
      Y[i , j] ~ dnorm(mu[i , j], tau.c)
      mu[i , j] &lt;- alpha[i] + beta[i] * (x[j] - xbar)
    }
    alpha[i] ~ dnorm(alpha.c, alpha.tau)
    beta[i] ~ dnorm(beta.c, beta.tau)
  }
  tau.c ~ dgamma(0.001, 0.001)
  sigma &lt;- 1 / sqrt(tau.c)
  alpha.c ~ dnorm(0.0, 1.0E-6)
  alpha.tau ~ dgamma(0.001, 0.001)
  beta.c ~ dnorm(0.0, 1.0E-6)
  beta.tau ~ dgamma(0.001, 0.001)
  alpha0 &lt;- alpha.c - xbar * beta.c
}</code></pre><p>denotes only a certain relationship between (logical or stochastic) nodes in a graph. Variables are either names of nodes within the program (when on the LHS of a sampling or assignement statement, like <code>alpha</code> or <code>sigma</code>), or otherwise constant parts of the “data” (like <code>N</code> and <code>xbar</code>), with which a model must be combined to instantiate it.</p><p>Loops are just a form of “plate notation”: they allow to concisely express repetition of equal statements over many constant indices, and are thus equivalent to their rolled-out form given the data.</p><blockquote><p>In the BUGS language the type information is fine grained: each component of a tensor can have different type information. […] One common case is where some components of a tensor have been observed while other components need to be estimated.</p></blockquote><p>In addition to standard type checking of semantic consistency between variables and function calls, like any other expression-based language does, BUGS has the additional task of making sense of the indexed variables, which can occur in many places and arbitrary order, and ensuring that stochasticity is only used where it is allowed (e.g., not on the LHS of assignments, or within loop ranges).</p><p>A “type checker” for BUGS would therefore have multiple purposes:</p><ol><li>Checking semantic constraints, such as correct argument types for functions and distributions,</li><li>Checking stochasticity constraints, such as constantness of loop ranges,</li><li>Unify types, ranks, and stochasticity of all variables – which can be specified in any order.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../array/">Array Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 30 March 2023 15:38">Thursday 30 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>